---
title: MQTT 发布和订阅
date: 2019-04-16 14:50:41
tags: 消息协议
---

【译文】

# 发布/订阅模式

发布/订阅模式（也称为pub / sub）提供了传统客户端 - 服务器体系结构的替代方案。在客户端 - 服务器模型中，客户端直接与端点通信。发布/ 订阅模型将发送消息的客户端（发布者）与接收消息的客户端（客户端）分离。发布者和订阅者从不直接相互联系。事实上，他们甚至不知道对方存在。它们之间的连接由第三个组件（代理）处理。代理的工作是过滤所有传入的消息并将它们正确地分发给订阅者。那么，让我们更深入地了解pub / sub的一些一般方面（我们将在一分钟内讨论MQTT细节）。

![](/images/publish-subscribe.svg)

MQTT发布/订阅
pub / sub最重要的方面是消息的发布者与接收者（订阅者）的分离。这种解耦有几个方面：

- 空间解耦：发布者和订阅者不需要彼此了解（例如，不交换IP地址和端口）。

- 时间解耦：发布者和订阅者不需要同时运行。

- 在发布或接收期间，不需要中断两个组件上的操作。

总之，发布/订阅模型消除了消息的发布者与接收者/订阅者之间的直接通信。代理的过滤活动使得可以控制哪个客户端/订户接收哪个消息。解耦有三个维度：空间，时间和同步。

# 可扩展性

发布/订阅比传统的客户端 - 服务器方法更好。这是因为代理上的操作可以高度并行化，并且可以以事件驱动的方式处理消息。消息缓存和消息的智能路由通常是提高可伸缩性的决定性因素。尽管如此，扩展到数百万个连接是一项挑战。使用群集代理节点可以实现如此高级别的连接，以使用负载平衡器将负载分布到更多单独的服务器上。（这个主题超出了当前文章的范围，我们将在另一篇文章中介绍它）。

# 邮件过滤

很明显，经纪人在酒吧/子流程中扮演着关键角色。但是，经纪人如何设法过滤所有消息，以便每个订阅者只收到感兴趣的消息？如您所见，代理有几个过滤选项：

***选项1：基于主题的过滤***
此过滤基于每个消息的主题或主题。接收客户端为经纪人订阅感兴趣的主题。从那时起，代理确保接收客户端获取发布到订阅主题的所有消息。通常，主题是具有分层结构的字符串，允许基于有限数量的表达式进行过滤。

***选项2：基于内容的过滤***
在基于内容的过滤中，代理基于特定内容过滤器语言过滤消息。接收客户端订阅他们感兴趣的消息的过滤查询。这种方法的一个重要缺点是必须事先知道消息的内容，不能加密或容易更改。

***选项3：基于类型的过滤***
当使用面向对象语言时，基于消息（事件）的类型/类进行过滤是一种常见做法。例如，订阅者可以侦听所有类型为Exception或任何子类型的消息。

当然，发布/订阅不是每个用例的答案。在使用此模型之前，您需要考虑一些事项。发布者和订阅者的脱钩是pub / sub的关键，它本身就存在一些挑战。例如，您需要了解预先如何构建已发布的数据。对于基于主题的过滤，发布者和订阅者都需要知道要使用哪些主题。要记住的另一件事是消息传递。发布者不能假设某人正在收听发送的消息。在某些情况下，没有订户可能会读取特定消息。

# MQTT

现在我们已经探索了一般的发布/订阅模型，让我们专注于MQTT。根据您想要实现的目标，MQTT体现了我们提到的pub / sub的所有方面：

- MQTT在空间上解耦发布者和订阅者。要发布或接收消息，发布者和订阅者只需要知道代理的主机名/ IP和端口

- MQTT按时间分离。尽管大多数MQTT用例都会近乎实时地传递消息，但如果需要，代理可以为不在线的客户端存储消息。（存储消息必须满足两个条件：客户端已与持久会话连接并订阅服务质量大于0的主题）。

- MQTT以异步方式工作。由于大多数客户端库异步工作并且基于回调或类似模型，因此在等待消息或发布消息时不会阻止任务。在某些用例中，同步是可取的并且是可能的。要等待某个消息，某些库具有同步API。但流程通常是异步的。

应该提到的另一件事是MQTT在客户端特别容易使用。大多数发布/订阅系统在代理端都有逻辑，但MQTT在使用客户端库时确实是pub / sub的本质，并且使其成为小型和受限设备的轻量级协议。

MQTT使用基于主题的消息过滤。每条消息都包含一个主题（主题），代理可以使用该主题来确定订阅客户端是否收到消息。请参阅MQTT Essentials的第5部分，以了解有关主题概念的更多信息。如果需要，您还可以使用HiveMQ MQTT代理和我们的自定义插件系统设置基于内容的过滤。

为了应对发布/ 订阅系统的挑战，MQTT具有服务质量（QoS）级别。您可以轻松指定消息从客户端成功传递到代理或从代理传递到客户端。但是有可能没有人订阅特定主题。如果这是一个问题，它取决于代理如何处理这种情况。例如，HiveMQ MQTT代理有一个插件系统，可以识别这种情况。您可以让代理执行操作，也可以只将每条消息记录到数据库中以进行历史分析。为了保持层次主题树的灵活性，非常仔细地设计主题树并为将来的用例留出空间是很重要的。如果您遵循这些策略，MQTT非常适合生产设置。

# 区别于消息队列

关于名称MQTT以及协议是否实现为消息队列存在很多混淆。我们将尝试阐明该主题并解释其中的差异。在我们的上一篇文章中，我们提到MQTT是指来自IBM的MQseries产品，与“消息队列”无关。无论名称来自何处，理解MQTT与传统消息队列之间的差异都很有用：

消息队列存储消息直到消耗它们 当您使用消息队列时，每个传入消息都存储在队列中，直到客户端（通常称为消费者）接收消息。如果没有客户端接收消息，则消息仍然卡在队列中并等待消耗。在消息队列中，任何客户端都不可能处理消息，因为如果没有人订阅主题，它就在MQTT中。


消息仅由一个客户端使用 另一个很大的区别是，在传统的消息队列中，消息只能由一个消费者处理。负载在队列的所有使用者之间分配。在MQTT中，行为恰恰相反：订阅该主题的每个订阅者都获得该消息。

队列已命名，必须显式创建 队列比主题严格得多。在可以使用队列之前，必须使用单独的命令显式创建队列。只有在命名和创建队列后才能发布或使用消息。相比之下，MQTT主题非常灵活，可以即时创建。